:toc:

Packages, Variables and Functions
---------------------------------

Packages
~~~~~~~~

* Every Go program is made up of packages.
  Programs start running in package main.
* By convention, the package name is the same as the last element of the import path
* imports can be grouped into a parenthesized, "factored" import statement.
  This is preferred over individual imports.
+
----
import (
    "fmt"
    "math"
)
----
+
* In Go, a name is exported if it begins with a capital letter.
* when doing a import "a/b", we can later just do b.VarFromB
* Function calls can precede function definition within the package

Functions
~~~~~~~~~

* 0 or more args. 0 or more return values
+
----
func add(x int, y int) int {
    return x + y
}
----
+
* When two or more consecutive named function parameters share a type, you can omit the type from all but the last.
+
----
x int, y int
to
x, y int
----
+
* Naked returns (to be avoided)
** This simply returns the variable with same name as parameters
+
----
func split(sum int) (x, y int) {
    x = sum * 4 / 9
    y = sum - x
    return
}
----
+
* functions associated with types are called methods

go inbuilt functions
^^^^^^^^^^^^^^^^^^^^

* make
** used to create a slice, map, chan
* len
* cap
* new
* append
* copy
* close
* delete
* complex
* real
* imag
* panic
* recover

Variables
~~~~~~~~~

* Initialization using the var statement. This is possible both inside functions and in global scope
+
----
var i, j int = 1, 2
----
+
* Using the := construct, var is skipped and type is assumed.
+
----
k := 3
c, python, java := true, false, "no!"
----
+
* var statements can also be factored like import statements
* _ can be used in place where a variable name isn't required.
* for all names, case matters. HeapSort and heapSort are different.
* Go typically uses camel case. Abbreviations may be all-caps.

Basic Types
^^^^^^^^^^^

----
bool  // either true or false
string
int  int8  int16  int32  int64
uint uint8 uint16 uint32 uint64 uintptr
byte // alias for uint8
rune // alias for int32
     // represents a Unicode code point
float32 float64
complex64 complex128
----

* Variables w/o Initialization is set to 0/false/empty-string
* Constants are declared like variables, but with the const keyword. Constants
  can be character, string, boolean, or numeric values. Constants cannot be
  declared using the := syntax.

constants
^^^^^^^^^

* can be nubmers, strings or booleans
* can be package level or function level
* iota is used for enumeration

const (
    a = iota
    b           /* implicit iota */
)

strings
^^^^^^^

* always utf-8
* enclsoed in double quotes
* single-quote strings represent one utf-8 character ( actually this is referred as rune)
* strings are immutable
* to edit strings, convert to array of runes
* backticks are for raw string literals that span multi-line.
* string(byteslice) coverts a byte slice to a string

----
s := "hello"               /* string */
c := []rune(s)             /* covert to array of runes */
c[0] = 'c'                 /* modify */
s2 := string(c)            /* covert array of runes to string */
fmt.Printf("%s\n", s2)
----


Flow control statements: for, if, else, switch and defer
--------------------------------------------------------

comments
~~~~~~~~

* comments are like c$$++. //$$ for one line and $$/* and */$$ for multi line

for
~~~~

* for .. init, condition, post separated by ;. Unlike other languages like C,
  Java, or Javascript there are no parentheses surrounding the three
  components of the for statement and the braces { } are always required.
+
----
func main() {
    sum := 0
    for i := 0; i < 10; i++ {
        sum += i
    }
    fmt.Println(sum)
}
----
+
* init and post are optional. At that point you can drop the semicolons: C's
  while is spelled for in Go. Omitting condition makes it a infinite loop
+
----
main() {
    sum := 1
    for sum < 1000 {
        sum += sum
    }
    fmt.Println(sum)
}
----
+
* Variables declared in for's initialization part have loop's scope

if
~~~~

* if statements are like its for loops; the expression need not be surrounded
  by parentheses ( ) but the braces { } are required
* the if statement can start with a short statement to execute before the
  condition. A var initailized here is availabe in if, else if and else.
+
----
func pow(x, n, lim float64) float64 {
    if v := math.Pow(x, n); v < lim {
        return v
    }
    return lim
}
----
+
* combine a stmt and err check like this, limiting the err's scope
+
----
if err := r.ParseForm(); err != nil {
   log.Print(err)
}
----

switch
~~~~~~

* Switch cases evaluate cases from top to bottom, stopping when a case succeeds
* A case body breaks automatically, unless it ends with a fallthrough statement
+
----
func main() {
    fmt.Print("Go runs on ")
    switch os := runtime.GOOS; os {
    case "darwin":
        fmt.Println("OS X.")
    case "linux":
        fmt.Println("Linux.")
    default:
        // freebsd, openbsd,
        // plan9, windows...
        fmt.Printf("%s.", os)
    }
}
----
+
* f isn't called if i == 0
+
----
switch i {
  case 0:
  case f():
}
----
+
* Switch without a condition is the same as switch true. This construct can be
  a clean way to write long if-then-else chains.

Defer
~~~~~

* A defer statement defers the execution of a function until the surrounding
  function returns. The args to any function called, are however, evaulated
  immediately
* Deferred function calls are pushed onto a stack. When a function returns, its
  deferred calls are executed in last-in-first-out order.

More types
----------

Pointer
~~~~~~~

* Like c, * is used for type. *T is a pointer of type T. & is for getting a
  variable's pointer, and *var is for deferencing or indirecting. However,
  there is no pointer arithmetic in go.

structs
~~~~~~~

* A struct is a collection of fields. Fields are accessed using dot
+
----
type Vertex struct {
    X int
    Y int
}
----
+
* To access the field X of a struct when we have the struct pointer p we could
  write (*p).X. However, that notation is cumbersome, so the language permits
  us instead to write just p.X, without the explicit dereference.
* Struct literal is much like c

arrays
~~~~~~

* [n]T is an array of n values of type T
+
----
func main() {
    var a [2]string
    a[0] = "Hello"
    a[1] = "World"
    fmt.Println(a[0], a[1])
    fmt.Println(a)

    primes := [6]int{2, 3, 5, 7, 11, 13}
    auto_size_detected_array := [...]int{2, 3, 5, 7, 11, 13}
    fmt.Println(primes)
}
----
+
* Go's array are values. Think of it as struct with indexed members. Passing
  arrays to function will pass entire copies. (No decaying of name to pointer)
* len(array) gives its length

slices
~~~~~~

* An array has a fixed size. A slice, on the other hand, is a
  dynamically-sized, flexible view into the elements of an array. In practice,
  slices are much more common than arrays.
* The type []T is a slice with elements of type T.
* This expression creates a slice of the first five elements of the array a
+
----
 a[0:5]
----
+
* A slice does not store any data, it just describes a section of an underlying
  array.  Changing the elements of a slice modifies the corresponding elements
  of its underlying array.  Other slices that share the same underlying array
  will see those changes.
* Slice - len and cap
* Can be created with a built-in function - make. Note the odditity. The first
  args is a type-name (and not a var-name)
+
----
func make([]T, len, cap) []T
----

map
~~~~

* Basically an unordered key-value hash-map
* Keys are any type on which == works. Value can be anything

channel
~~~~~~~

* communication mechanism
* Is always of a given type

goroutine
~~~~~~~~~

* concurrent function execution
* go statement creates it

interface
~~~~~~~~~~

* Collection of methods

composite literal
~~~~~~~~~~~~~~~~~

* Not exactly a type, but I just put here
* Initializes a slice or a struct
+
----
var palette = []color.Color{color.White, color.Black}
anim := gif.GIF{LoopCount: nframes}
----


Popular types/interfaces
-------------------------

error
~~~~~~

nil is no error. Otherwise some error

Other Go statements
-------------------

range
~~~~~

Typically used in for statements. Is like an iterator. Gives 0-based-index, value

----
for i := 1; i < len(os.Args); i++ {
   s += sep + os.Args[i]
   sep = " "
}
----

Managing Go code
----------------

* Go programmers typically keep all their Go code in a single workspace.
* A workspace contains many version control repositories (managed by Git, for example).
* Each repository contains one or more packages.
* Each package consists of one or more Go source files in a single directory.
* The path to a package's directory determines its import path.

Useful Statements
-----------------


Packages in standard library
-----------------------------

os
~~~

* os.Args[] - slice of cmd line args. os.Args[0] is the command itself.
* os.Stdin  - a io.Reader for stdin
* os.Open   - opens a file! Check the err first and then use the File*
* os.Exit(1) - exit with a error code.

fmt
~~~

* fmt.Println
* fmt.Printf
* fmt.Fprintf
+
----
fmt.Println(split(17))
var i int
fmt.Println(i, c, python, java)

fmt.Printf("Regular c style printing with formats:%d", i)
----
+
** %v is verb(name in go for format-specifier) to choose the default format for the passed type

strings
~~~~~~~

* strings.Join(a []string, sep string)
** concatenates elements of a to make a bing string using sep

bufio
~~~~~

* Scanner
** Reads a input and breaks it into lines
** Scanner.Scan() - reads one line, strips the newline. Returns True/false on whether a line was read or not.
** Scanner.Text() - gets the line previous read by Scan()

* bufio.NewScanner
** returns a *Scanner from a io.Reader

io/ioutil
~~~~~~~~~~

* ReadFile
** Given a filename returns byte slice/err of file contents

io
~~~

* Discard - sth like /dev/null sink

net/http
~~~~~~~~

* http.Get(url) resp,err

time
~~~~

* time.Now()
* Time - unexported type for Time
* Duration - nano-sec between 2 instances (upto 290 years)

sync
~~~~

* sync.Mutex - mutex TYPE

Reading Help
------------

* use godoc
+
----
godoc <pkg-name>
godoc image/gif
----
+
* Has CONSTANTS, FUNCTIONS, TYPES

Read later
----------

* https://blog.golang.org/defer-panic-and-recover[Defer-panic-and-recover]


